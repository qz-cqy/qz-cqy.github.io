<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.ak-ioi.cf</id>
    <title>rui_er 的博客</title>
    <updated>2020-10-30T10:16:17.821Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.ak-ioi.cf"/>
    <link rel="self" href="https://blog.ak-ioi.cf/atom.xml"/>
    <subtitle>三思而后码</subtitle>
    <logo>https://blog.ak-ioi.cf/images/avatar.png</logo>
    <icon>https://blog.ak-ioi.cf/favicon.ico</icon>
    <rights>All rights reserved 2020, rui_er 的博客</rights>
    <entry>
        <title type="html"><![CDATA[题解 P7041@洛谷 【[NWRRC2016]King’s Heir】]]></title>
        <id>https://blog.ak-ioi.cf/post/solution-luogu-p7041/</id>
        <link href="https://blog.ak-ioi.cf/post/solution-luogu-p7041/">
        </link>
        <updated>2020-10-30T10:15:08.000Z</updated>
        <content type="html"><![CDATA[<p>最近 kkk 传了好多题啊，然后就随便挑了一个（也就是目前编号最大的）来做，拿到了首 A <s>（虽然好像没啥用</s> 。</p>
<hr>
<p>题意：国王有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个儿子，他想要把王位传给年龄<strong>超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>18</mn></mrow><annotation encoding="application/x-tex">18</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">8</span></span></span></span> 岁的中最小的</strong>儿子。题目保证不存在两个儿子在同一天出生。假设所有年份的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 月均为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>28</mn></mrow><annotation encoding="application/x-tex">28</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">8</span></span></span></span> 天。</p>
<p>考虑先根据生日将所有儿子排序，然后枚举并计算与国王生日的差即可。排序时可以写比较函数，根据年、月、日三个关键字排序。那么怎么计算两个日期之间的间隔呢？</p>
<p>分两种情况：在同一年或不在同一年。</p>
<p>对于在同一年的，我们枚举两个月之间的完整月，将结果加上该月的天数，再通过简单推导计算出两侧零散月的天数即可。</p>
<p>对于不在同一年的，枚举中间年份加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>365</mn></mrow><annotation encoding="application/x-tex">365</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">6</span><span class="mord">5</span></span></span></span>，然后枚举两侧零散年按照上面类似方法计算即可。</p>
<p>我写的比较暴力，但也很容易理解，因为数据很小就没卡这里的常数。</p>
<hr>
<p>代码：</p>
<pre><code class="language-cpp">//By: Luogu@rui_er(122461)
#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 105, mx = 18 * 365;
const int month[] = {-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

int n;
struct Node {
	int d, m, y, id;
	Node(int a=0, int b=0, int c=0, int d=0) : d(a), m(b), y(c), id(d) {}
	~Node() {}
	void read() {scanf(&quot;%d%d%d&quot;, &amp;this-&gt;d, &amp;this-&gt;m, &amp;this-&gt;y);}
	friend bool operator &lt; (const Node &amp;a, const Node &amp;b) {
		if(a.y != b.y) return a.y &lt; b.y;
		if(a.m != b.m) return a.m &lt; b.m;
		return a.d &lt; b.d;
	}
}king, son[N];

int calc(const Node &amp;a, const Node &amp;b) {
	int res = 0;
	if(a.y == b.y) {
		if(a.m == b.m) return b.d - a.d + 1;
		for(int i=a.m+1;i&lt;b.m;i++) res += month[i];
		res += month[a.m] - a.d + 1 + b.d;
		return res;
	}
	for(int i=a.y+1;i&lt;b.y;i++) res += 365;
	for(int i=a.m+1;i&lt;=12;i++) res += month[i];
	for(int i=1;i&lt;b.m;i++) res += month[i];
	res += month[a.m] - a.d + 1 + b.d;
	return res;
}

int main() {
	king.read();
	scanf(&quot;%d&quot;, &amp;n);
	for(int i=1;i&lt;=n;i++) son[i].read(), son[i].id = i;
	sort(son+1, son+1+n);
	for(int i=n;i;i--) if(calc(son[i], king) &gt; mx) return printf(&quot;%d\n&quot;, son[i].id), 0;
	puts(&quot;-1&quot;);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[bilibili ctf 2020 程序员节网络安全挑战 解题报告]]></title>
        <id>https://blog.ak-ioi.cf/post/bilibili-ctf-2020/</id>
        <link href="https://blog.ak-ioi.cf/post/bilibili-ctf-2020/">
        </link>
        <updated>2020-10-27T11:39:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="bilibili-ctf-2020-程序员节网络安全挑战-解题报告">bilibili ctf 2020 程序员节网络安全挑战 解题报告</h1>
<p>比赛已经结束，最终得分：80pts。</p>
<p><a href="https://www.bilibili.com/blackboard/activity-20201024.html">地址</a> 里面的第二个“33的挑战状 —— 首届哔哩哔哩安全挑战赛”</p>
<p>注：可能有一些题（例如 T5）中每人的 flag 不同，请勿尝试直接输入博客中的 flag 进行解题。</p>
<h1 id="t1">T1</h1>
<p>题目地址进不去？没关系，万能的 view-source 大法好！</p>
<p>进入 <code>view-source:http://45.113.201.36/index.html</code> 发现这几行代码：</p>
<pre><code class="language-js">&lt;script&gt;
    $.ajax({
    url: &quot;api/admin&quot;,
    type: &quot;get&quot;,
    success:function (data) {
        //console.log(data);
        if (data.code == 200){
            // 如果有值：前端跳转
            var input = document.getElementById(&quot;flag1&quot;);
            input.value = String(data.data);
        } else {
            // 如果没值
            $('#flag1').html(&quot;接口异常，请稍后再试～&quot;);
        }
    }
})
&lt;/script&gt;
</code></pre>
<p>flag1 不就是过关要用的东西吗，手动输网址进入 <code>http://45.113.201.36/api/admin</code> 看到下面这个 xml：</p>
<pre><code class="language-xml">{&quot;code&quot;:200,&quot;data&quot;:&quot;1b2a3078-01f7b16d-8e620caf-f21f54e0&quot;,&quot;msg&quot;:&quot;&quot;}
</code></pre>
<p>回到答题首页，题号为 1，flag 为 <code>1b2a3078-01f7b16d-8e620caf-f21f54e0</code> 即可获得 10pts。</p>
<h1 id="t2">T2</h1>
<p>老规矩，view-source 一下，发现下面那个 api 地址进不去了。</p>
<p>老老实实地回到原来网址，一行大字：<code>需要使用bilibili Security Browser浏览器访问～</code></p>
<p>这是啥浏览器，百度搜不到？</p>
<p>果断想到改 userAgent！</p>
<p>例如我的 fireFox 就在网址栏输入 <code>about:config</code>，搜索 <code>general.useragent.override</code>，就可以改了。</p>
<p><strong>警告：更改前请务必备份好原来的 userAgent，可以到 <a href="http://www.all-tool.cn/Tools/ua/">这里</a> 查看！否则可能导致一些功能无法正常使用！</strong></p>
<p>（例如我原来的就是：<code>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:82.0) Gecko/20100101 Firefox/82.0</code>）</p>
<p>将 UA 改成 <code>bilibili Security Browser</code>，刷新界面，发现 <code>flag2: 6a4c1f7d-be44b65f-3583423d-9f5a63c9</code>，填入答案即可。</p>
<h1 id="t3">T3</h1>
<p>填个密码？按照惯例管理员账号为 <code>admin</code>，随手试一发密码 <code>bilibili</code> 竟然对了 /jk。</p>
<p>得到 flag：<code>9c91dce9-31eafdca-89be9852-7e1fb730</code>。</p>
<h1 id="t4">T4</h1>
<p>超级管理员，想到 <code>Administrator</code>，MD5 32 位加密得到 <code>7b7bc2512ee1fedcd76bdc68926d4f7b</code>，F12 存储里面看到 session，我们发送一个 session 和 role 的请求头到 <code>http://45.113.201.36/api/ctf/4</code>，其中 role 是上面那个 MD5，得到我的 flag：<code>3b889d30-514ddd74-c8264fbb-2b6d25b4</code>。</p>
<h1 id="t5">T5</h1>
<p>类似的办法，设置好请求头，获取到 user 后发送请求到 <code>http://45.113.201.36/api/ctf/5?uid={uid}</code> 即可，得到我的 flag：<code>9537ded8-b97fe4dc-008608c8-d69723ed</code>。</p>
<p>至于怎么获取到 user 嘛，根据源码界面得到：<s>暴力破解大法好（</s></p>
<h1 id="t10">T10</h1>
<p>果然就是毒瘤，“结束亦是开始”竟然真的倒着来！</p>
<p>找到了 <a href="http://45.113.201.36/blog/test.php">这个</a>，jsfuck 解密后“程序员最多的地方”，就是 GitHub，然后发现 <a href="https://github.com/interesting-1024/end/blob/main/end.php">这个</a>，里面有 <code>end.php</code> 源码，进入 <code>http://45.113.201.36/blog/end.php</code>，发现显示的一致，尝试 <code>http://45.113.201.36/blog/end.php?id[0]=1</code>，发现“还差一点点啦~”</p>
<p>尝试 <code>http://45.113.201.36/blog/end.php?id[]=1&amp;url=./flag.txt</code>，发现一个图片，以文本形式打开，搜索 flag，找到最终答案：<code>2ebd3b08-47ffc478-b49a5f9d-f6099d65</code>。</p>
<h1 id="t8">T8</h1>
<p>发现 6379 端口是开放的，用 redis 获取 flag8：<code>d436b982-2b81aa54-49a8d2db-87ab951a</code>。</p>
<p>此页面的其他 flag 应该是假的。</p>
<h1 id="t6">T6</h1>
<p>emm，直接用 python 瞎二分调 API 找 flag（</p>
<p>结果：<code>a2b0883c-ffbb8d17-9a3bbf1c-ed600c80</code>。</p>
<h1 id="t7">T7</h1>
<p>未完成</p>
<h1 id="t9">T9</h1>
<p>未完成</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P5072@洛谷 【[Ynoi2015]盼君勿忘】]]></title>
        <id>https://blog.ak-ioi.cf/post/solution-luogu-p5072/</id>
        <link href="https://blog.ak-ioi.cf/post/solution-luogu-p5072/">
        </link>
        <updated>2020-10-23T14:07:41.000Z</updated>
        <content type="html"><![CDATA[<p>给定一个序列，每次查询一个区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 中所有子序列分别去重后的和  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mtext> </mtext><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mi>p</mi></mrow><annotation encoding="application/x-tex">s\bmod{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span><span class="mbin"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span></span></span></span></span> 的结果。</p>
<hr>
<p>乍一看好像不太可做，仔细分析发现有点规律：</p>
<p><strong>在一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 的序列中，一个数出现次数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>。则有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>a</mi><mo>−</mo><mi>b</mi></mrow></msup></mrow><annotation encoding="application/x-tex">2^{a-b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span></span></span></span></span> 个子序列不包含该元素，它的贡献是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>a</mi></msup><mo>−</mo><msup><mn>2</mn><mrow><mi>a</mi><mo>−</mo><mi>b</mi></mrow></msup></mrow><annotation encoding="application/x-tex">2^a-2^{a-b}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">b</span></span></span></span></span></span></span></span></span></span></span></span>。</strong></p>
<p>问题转化为如何快速求出每一个数的贡献值。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>、离线、维护数列，想到什么？莫队！</p>
<p>我们使用<strong>莫队</strong>记录<strong>双向链表</strong>（建议手写），维护每个数分别的出现次数，下标表示数，内容为出现次数。则这个链表的元素个数大致在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span> 级别。在跳到当前区间后，枚举维护的链表，对于每个元素分别算出贡献值后相加即可。</p>
<p>还剩下最后一个问题：如何快速求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>？普通的快速幂可能做不到，因为带一只 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>log</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">\log</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span></span></span></span>，容易被卡。果断选用<strong>光速幂</strong>。</p>
<p>光速幂是什么呢？就是一种 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><msqrt><mi>n</mi></msqrt><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(\sqrt{n})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 预处理、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mn mathvariant="script">1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathcal">1</span><span class="mclose">)</span></span></span></span></span> 查询的，求特定底数的幂的快速方法。具体方案是：预处理 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>1</mn></msup><mo separator="true">,</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msup><mn>2</mn><msqrt><mi>n</mi></msqrt></msup></mrow><annotation encoding="application/x-tex">2^1,2^2,\cdots,2^{\sqrt{n}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1215735em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9271335em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8059050000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-2.765905em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.234095em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><msqrt><mi>n</mi></msqrt></msup><mo separator="true">,</mo><msup><mn>2</mn><mrow><mn>2</mn><mo>×</mo><msqrt><mi>n</mi></msqrt></mrow></msup><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^{\sqrt{n}},2^{2\times\sqrt{n}},\cdots,2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1215735em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9271335em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8059050000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-2.765905em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.234095em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9271335em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mbin mtight">×</span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8059050000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-2.765905em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.234095em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，然后根据商和余数即可 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><mn mathvariant="script">1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O(1)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathcal">1</span><span class="mclose">)</span></span></span></span></span> 求出结果。</p>
<hr>
<p>代码：</p>
<pre><code class="language-cpp">//By: Luogu@rui_er(122461)
#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const ll N = 1e5+5;

ll n, m, a[N], SIZE, cnt[N], s[N], ans[N];
#define whichBlock(x) (\
	(x-1)/SIZE+1\
)
struct Query {
	ll l, r, p, id;
	Query(ll a=0, ll b=0, ll c=0, ll d=0) : l(a), r(b), p(c), id(d) {}
	~Query() {}
	friend bool operator &lt; (const Query &amp;a, const Query &amp;b) {
		ll x = whichBlock(a.l), y = whichBlock(b.l);
		if(x == y) return a.r &lt; b.r;
		return x &lt; y;
	}
}q[N];
struct myList {
	struct Node {
		ll pre, nxt;
		Node(ll a=0, ll b=0) : pre(a), nxt(b) {}
		~Node() {}
	}nd[N];
	ll tot;
	myList(ll a=0) : tot(a) {}
	~myList() {}
	void insert(ll x) {
		nd[tot].nxt = x;
		nd[x].pre = tot;
		tot = x;
	}
	void erase(ll x) {
		if(x != tot) {
			nd[nd[x].pre].nxt = nd[x].nxt;
			nd[nd[x].nxt].pre = nd[x].pre;
		}
		else {
			nd[nd[x].pre].nxt = 0;
			tot = nd[x].pre;
		}
		nd[x] = Node();
	}
}lst;
namespace qpow {
	ll pow1[N], pow2[N];
	void initPow(ll mod) {
		pow1[0] = pow2[0] = 1;
		for(ll i=1;i&lt;=SIZE;i++) pow1[i] = pow1[i-1] * 2 % mod;
		for(ll i=1;i&lt;=SIZE;i++) pow2[i] = pow2[i-1] * pow1[SIZE] % mod;
	}
	ll calc(ll x, ll mod) {return pow1[x%SIZE]*pow2[x/SIZE]%mod;}
}
void upd(ll x, ll k) {
	if(!(s[cnt[a[x]]]-=a[x])) lst.erase(cnt[a[x]]);
	if(!s[cnt[a[x]]+=k]) lst.insert(cnt[a[x]]);
	s[cnt[a[x]]] += a[x];
}

int main() {
	scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
	SIZE = sqrt(n);
	for(ll i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;, &amp;a[i]);
	for(ll i=1;i&lt;=m;i++) scanf(&quot;%lld%lld%lld&quot;, &amp;q[i].l, &amp;q[i].r, &amp;q[i].p), q[i].id = i;
	sort(q+1, q+1+m);
	ll l = 1, r = 0;
	for(ll i=1;i&lt;=m;i++) {
//		printf(&quot;QUERY #%d: id=%d l=%d r=%d p=%d\n&quot;, i, q[i].id, q[i].l, q[i].r, q[i].p);
		qpow::initPow(q[i].p);
		while(l &gt; q[i].l) upd(--l, 1);
		while(r &lt; q[i].r) upd(++r, 1);
		while(l &lt; q[i].l) upd(l++, -1);
		while(r &gt; q[i].r) upd(r--, -1);
		for(ll j=lst.nd[0].nxt;j;j=lst.nd[j].nxt) {
//			printf(&quot;LIST POSITION: %d\n&quot;, j);
			ll _1 = qpow::calc(r-l+1, q[i].p);
			ll _2 = qpow::calc(r-l+1-j, q[i].p);
			ll _3 = ((_1 - _2) * s[j] + q[i].p) % q[i].p;
			ans[q[i].id] = (ans[q[i].id] + _3 + q[i].p) % q[i].p;
		}
	}
	for(ll i=1;i&lt;=m;i++) printf(&quot;%lld\n&quot;, ans[i]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF1148F@洛谷 | 1148F@Codeforces 【Foo Fighters】]]></title>
        <id>https://blog.ak-ioi.cf/post/solution-luogu-cf1148f-codeforces-1148f/</id>
        <link href="https://blog.ak-ioi.cf/post/solution-luogu-cf1148f-codeforces-1148f/">
        </link>
        <updated>2020-10-20T10:35:31.000Z</updated>
        <content type="html"><![CDATA[<p>有点毒瘤的贪心题，当然也可能是我太菜了。</p>
<hr>
<p>翻译的挺清楚的了，直接说思路：</p>
<p>我们考虑在读入时顺便把每个数的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mi>a</mi><mi>s</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">mask</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 权值的<strong>二进制最高位</strong>预处理出来，同时统计权值和。由于正数变负数和负数变正数本质上是一样的，为了方便考虑，如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 权值和为负数，将所有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 取相反数。</p>
<p>随后考虑如何贪心：</p>
<p>枚举每一位，统计<strong>二进制最高位为该位</strong>的所有数的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span> 权值和。如果这个权值和小于或等于零，那么没有修改该位的必要，因为修改不会使总权值增加，反而可能减少。如果最高位为该位的权值和大于零，那么修改该位比不修改更优。在答案变量中将该位置为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，并且枚举所有数修改即可。</p>
<p>以上为正解，复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n\log{x})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span></span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 为变量范围（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>62</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{62}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>）。</p>
<p><strong>坑点：贪心时必须从低位到高位枚举每一位进行更新，否则后面的更改可能导致更高位的决策被干扰，得不到正确答案！</strong></p>
<hr>
<p>代码：</p>
<pre><code class="language-cpp">//By: Luogu@rui_er(122461)
#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const ll N = 3e5+5, bit = 62;

ll n, ans;
struct Node {ll val, mask, bits;}a[N];

int main() {
	scanf(&quot;%llu&quot;, &amp;n);
	for(ll i=1;i&lt;=n;i++) {
		scanf(&quot;%lld%lld&quot;, &amp;a[i].val, &amp;a[i].mask);
		ans += a[i].val;
		for(ll _=bit;_+1;_--) if((a[i].mask &gt;&gt; _) &amp; 1) {a[i].bits = _; break;}
	}
	if(ans &lt; 0) for(ll i=1;i&lt;=n;i++) a[i].val = -a[i].val;
	ans = 0;
	for(ll _=0;_&lt;=bit;_++) {
		ll s = 0;
		for(ll i=1;i&lt;=n;i++) s += (a[i].bits == _) * a[i].val;
		if(s &lt;= 0) continue;
		ans |= (1LL &lt;&lt; _);
		for(ll i=1;i&lt;=n;i++) a[i].val *= ((a[i].mask &gt;&gt; _) &amp; 1) ? -1 : 1;
	}
	printf(&quot;%lld\n&quot;, ans);
//	puts(&quot;----------\nDEBUG: &quot;); for(ll i=1;i&lt;=n;i++) printf(&quot;%lld\n&quot;, a[i].val);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF1375F@洛谷 | 1375F@Codeforces 【Integer Game】]]></title>
        <id>https://blog.ak-ioi.cf/post/solution-luogu-cf1375f-codeforces-1375f/</id>
        <link href="https://blog.ak-ioi.cf/post/solution-luogu-cf1375f-codeforces-1375f/">
        </link>
        <updated>2020-10-14T10:33:43.000Z</updated>
        <content type="html"><![CDATA[<p>题意：<strong>交互题</strong>，三堆石子，石子个数分别为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo>∈</mo><mrow><mo fence="true">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo fence="true">]</mo></mrow><mo>∩</mo><mi mathvariant="normal">Z</mi></mrow><annotation encoding="application/x-tex">a,b,c\in\left[1,10^9\right]\cap\rm{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Z</span></span></span></span></span></span>，选择先手或者后手进行游戏。先手给定一个数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>∈</mo><mrow><mo fence="true">[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><msup><mn>0</mn><mn>12</mn></msup><mo fence="true">]</mo></mrow><mo>∩</mo><mi mathvariant="normal">Z</mi></mrow><annotation encoding="application/x-tex">k\in\left[1,10^{12}\right]\cap\rm{Z}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">Z</span></span></span></span></span></span>，后手将一堆石子个数增加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，不能连续增加同一堆两次。如果有两堆石子个数一样，后手输；如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">10^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> 次内先手没有赢，则后手赢。问谁有必胜策略。</p>
<hr>
<p>首先，我们考虑什么时候后手会输。</p>
<p>假设此时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi><mo>&lt;</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a\lt b\lt c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>：</p>
<ol>
<li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>−</mo><mi>a</mi><mi mathvariant="normal">≠</mi><mi>c</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">b-a\ne c-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，则不论可以修改哪个，后手均不会输。</li>
<li>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>−</mo><mi>a</mi><mo>=</mo><mi>c</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">b-a=c-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，此时如果不能修改 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，则可以构造出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo>=</mo><mi>c</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">k=b-a=c-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 使得后手必败；如果可以修改 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，则不能保证。</li>
</ol>
<p>得出结论：<strong>当且仅当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a,b,c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span></span></span></span> 成等差数列，且最大数不能被修改时后手败。</strong></p>
<p>我们考虑是否能构造一种方法，使得在若干步后，三堆石子满足这一条件。</p>
<p>考虑如何能得到等差数列，且最大数不能修改？设原来三堆石子为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&lt;</mo><mi>b</mi><mo>&lt;</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a\lt b\lt c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>c</mi><mo>−</mo><mi>b</mi><mo separator="true">,</mo><mi>y</mi><mo>=</mo><mi>c</mi><mo>−</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">x=c-b,y=c-a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，并且最大数不能被修改，那么就可以构造 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>=</mo><mi>c</mi><mo>×</mo><mn>3</mn><mo>−</mo><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">k=x+y=c\times 3-(a+b+c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span></span></span></span> 满足条件。</p>
<p>为啥？假设修改 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>，则三个数变为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>c</mi><mo>×</mo><mn>3</mn><mo>−</mo><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo>)</mo><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a+c\times 3-(a+b+c),b,c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span></span></span></span>，即为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mi>c</mi><mo>−</mo><mi>b</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">2\times c-b,b,c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>2</mn><mo>×</mo><mi>c</mi><mo>−</mo><mi>b</mi><mo>)</mo><mo>−</mo><mi>c</mi><mo>=</mo><mi>c</mi><mo>−</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">(2\times c-b)-c=c-b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，符合上面的描述。修改 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 同理。</p>
<p>此时我们发现，中位数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，即原来的最大数；公差可以根据这一点推出：用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 减去另一个没有变化的数。</p>
<p>问题转化为如何固定最大值不能动。我们一开始构造 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>inf</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">k=\inf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mop">in<span style="margin-right:0.07778em;">f</span></span></span></span></span>，即大于任何一个数的数，此时被修改的不管是哪个，都是修改后的最大值。记录这个最大值，然后按照上面说的做即可。</p>
<hr>
<p>总结：首先构造 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>inf</mi><mo>⁡</mo></mrow><annotation encoding="application/x-tex">k=\inf</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mop">in<span style="margin-right:0.07778em;">f</span></span></span></span></span>，获得最大值位置，用指针记录。然后根据最大值，构造 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mi>c</mi><mo>×</mo><mn>3</mn><mo>−</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">k=c\times 3-s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span> 为这个最大值，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span></span></span></span> 为三个数的和。最后得到一个最大数不能修改的等差数列，构造 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 为公差即可。</p>
<p><s>没错你没看错，先手在三步以内必胜。</s></p>
<hr>
<p>代码：</p>
<pre><code class="language-cpp">//By: Luogu@rui_er(122461)
#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const ll inf = 1e10;

ll a[3], *p, k, s;
ll interact(ll x) {
	printf(&quot;%lld\n&quot;, x);
	fflush(stdout);
	ll res;
	scanf(&quot;%lld&quot;, &amp;res);
	if(!res) exit(0);
	a[--res] += x;
	return res;
}

int main() {
	scanf(&quot;%lld%lld%lld&quot;, &amp;a[0], &amp;a[1], &amp;a[2]);
	puts(&quot;First&quot;); fflush(stdout);
	s = a[0] + a[1] + a[2] + inf;
	k = interact(inf);
	p = &amp;a[k];
	k = interact((*p)*3-s);
	ll _ = 3 - (p - a) - k;
	k = interact((*p)-a[_]);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P3812@洛谷 【【模板】线性基】]]></title>
        <id>https://blog.ak-ioi.cf/post/solution-luogu-p3812/</id>
        <link href="https://blog.ak-ioi.cf/post/solution-luogu-p3812/">
        </link>
        <updated>2020-10-12T09:56:36.000Z</updated>
        <content type="html"><![CDATA[<p>刚刚口胡并学了线性基，就来写篇题解，记录一下。</p>
<hr>
<p>从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个数中选取若干个，使他们的异或和最大。</p>
<p>既然是异或和，因为异或是位运算，肯定要用到二进制的。</p>
<p>考虑异或和的性质：对于这一位，有奇数个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 求异或和，结果为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>；有偶数个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 求异或和，结果为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。这一性质告诉我们，当我们对当前位置完成决策的时候，后面所有位的异或和无论怎样也不会影响到现有结果。想到从高位到低位扫一遍，对每一位取最优决策，就是结果。</p>
<p>但因为每一位二进制位可能有很多 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，不方便进行决策，于是思考能不能<strong>构造一个序列，使得在这个序列中，任取若干个数求异或和的结果组成的集合，与原序列求异或和的结果组成的集合一样，且这个序列的每个数的最高位 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 所在位数不一样</strong>呢？这种情况下，我们在新序列上决策和在原数列上决策是等效的。</p>
<p><s>但是我太菜了发现并不会构造，怎么办呢？上百度搜线性基正解吧。</s></p>
<p>结果一搜发现我已经口胡出来了，愣是傻傻的不会构造 /jk /jk，那就继续说吧。</p>
<p>线性基就是由原数列集合构造出的满足下面性质的集合：</p>
<ol>
<li>线性基内的元素可以通过求异或和，得到原集合的元素任意求异或和得到的所有值。</li>
<li>线性基是满足上面性质的最小的集合。</li>
<li>线性基不存在异或和为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的子集。</li>
<li>线性基中，任取不同的子集求异或和，得到的答案不同。（即线性基子集的异或和具有唯一性）</li>
<li>线性基内所有元素的二进制最高位互不相同。</li>
</ol>
<p>考虑进行构造：</p>
<p>在线性基插入元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，从高位向低位扫，如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 二进制下该位为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，且不存在最高位为该位的线性基元素，将其加入线性基。如果该位为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，但已经存在元素的最高位为该位，将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 异或上该元素，继续向后搜。</p>
<p>要查询最大值，从高位到低位枚举线性基中最高位为该位的元素，如果答案异或上这个数比原来的答案大，更新答案。这样因为更低位的结果无法影响当前位，因此这一方法是最优的。</p>
<hr>
<p>代码：</p>
<pre><code class="language-cpp">//By: Luogu@rui_er(122461)
#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const ll N = 55, bit = 50;
 
ll n, a, p[N];
void insert(ll k) {
	for(ll i=bit;i&gt;=0;i--) {
		if(!(k&amp;(1LL&lt;&lt;i))) continue;
		if(!p[i]) return p[i] = k, void();
		k ^= p[i];
	}
}
ll maxXor() {
	ll res = 0;
	for(ll i=bit;i&gt;=0;i--) res = max(res, (res^p[i]));
	return res;
}

int main() {
	scanf(&quot;%lld&quot;, &amp;n);
	while(n--) {scanf(&quot;%lld&quot;, &amp;a); insert(a);}
	printf(&quot;%lld\n&quot;, maxXor());
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P6830@洛谷 【[IOI2020]连接擎天树】]]></title>
        <id>https://blog.ak-ioi.cf/post/solution-luogu-p6830/</id>
        <link href="https://blog.ak-ioi.cf/post/solution-luogu-p6830/">
        </link>
        <updated>2020-10-11T11:07:42.000Z</updated>
        <content type="html"><![CDATA[<p>破事水：IOI2020 结束后就想要写这题，但是 spj 当时是锅的，修好后我就<s>秉承鸽子的良好品德</s>一直咕到了现在。</p>
<p>因为 CSP2020 考的有点自闭，所以来做一道 IOI 真题放松一下。</p>
<hr>
<p>题意简述：构造一个无向图，使得任意两个点之间路径个数与题目给出的相同。</p>
<hr>
<p>思路：</p>
<p><strong>注：因为洛谷与其他 oj（包括 IOI 官方）的评测方式不同，本题解代码以洛谷为准，在其他 oj 可能无法直接取的 AC，请额外注意。</strong></p>
<p>首先，如果一个图中的一个连通块，拥有<strong>多于</strong>一个环，那么这种情况肯定不符合题意。为啥呢？画个图理解一下。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/ce80n3m9.png" alt="" loading="lazy"></figure>
<p>以这张图上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mo>→</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">4\rightarrow 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span> 的路径为例，共有如下情况：</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mo>→</mo><mn>0</mn><mo>→</mo><mn>1</mn><mo>→</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">4\rightarrow 0\rightarrow 1\rightarrow 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mo>→</mo><mn>0</mn><mo>→</mo><mn>1</mn><mo>→</mo><mn>5</mn><mo>→</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">4\rightarrow 0\rightarrow 1\rightarrow 5\rightarrow 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mo>→</mo><mn>3</mn><mo>→</mo><mn>2</mn><mo>→</mo><mn>1</mn><mo>→</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">4\rightarrow 3\rightarrow 2\rightarrow 1\rightarrow 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mo>→</mo><mn>3</mn><mo>→</mo><mn>2</mn><mo>→</mo><mn>1</mn><mo>→</mo><mn>5</mn><mo>→</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">4\rightarrow 3\rightarrow 2\rightarrow 1\rightarrow 5\rightarrow 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span></li>
</ol>
<p>因为跨过了两个环，路径条数显然多于三个。</p>
<p>我们得到了构造的初步方向：<strong>原图必须是一个由树或基环树组成的森林</strong>。</p>
<p>接着找规律：</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.luogu.com.cn/upload/image_hosting/tjnvm6dg.png" alt="" loading="lazy"></figure>
<p>对于这棵基环树，通过手推，发现：</p>
<ol>
<li>对于任意两个点（比如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo separator="true">,</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">2,4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span></span></span></span>），它们之间的路径如果全在环外，那么它们之间<strong>有且仅有一条路径</strong>。</li>
<li>对于任意两个点（比如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn><mo separator="true">,</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">6,3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span></span></span></span>），它们之间的路径如果至少有一条边一定在环上，那么它们之间<strong>有两条路径</strong>。</li>
</ol>
<p>换句话说，就是把所有环上的边先删掉，如果还在连通块内，就只有一条边。</p>
<p>可以看到，<strong>如果题目中要求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u,v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 之间有三条路径，此时无解</strong>。</p>
<p>我们先 dfs 一遍<strong>求出连通块</strong>，如果连通块内存在要求有三条路径的边，就直接判掉。如果有两个点之间路径要求为零，也可以判掉。剩下的情况就分为两种：树和基环树。</p>
<p>对于连通块内只要求两两之间有一条路径，将其中一个点和连通块内其他所有点相连即可。对于基环树，我们先不考虑路径数为二的边，在剩下的路径数为一的边里面再次 dfs 求出环外的连通块，按照相同方式连接后，每个环外连通块取一个点，将这些点依次连城环即可。</p>
<p>至此我们便得到了正解。</p>
<hr>
<p>代码：</p>
<pre><code class="language-cpp">//By: Luogu@rui_er(122461)
#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1005;

void build(vector&lt;vector&lt;int&gt; &gt; b);

int n, ma, vis[N];
vector&lt;int&gt; block, edge, circle; // 分别为连通块、基环树上的树边和基环树上的环 
vector&lt;vector&lt;int&gt; &gt; graph, res;
void add(int u, int v) {res[u][v] = res[v][u] = 1;}
void dfs(int u) {
//	printf(&quot;DFS %d\n&quot;, u);
	vis[u] = 1;
	block.push_back(u);
	for(int v=0;v&lt;n;v++) {
		ma = max(ma, graph[u][v]);
		if(!vis[v] &amp;&amp; graph[u][v]) dfs(v);
	}
}
void dfsCircle(int u) {
	vis[u] = 2;
	edge.push_back(u);
	for(int v=0;v&lt;n;v++) if(vis[v] == 1 &amp;&amp; graph[u][v] == 1) dfsCircle(v);
}
int construct(vector&lt;vector&lt;int&gt; &gt; p) {
//	puts(&quot;CONSTRUCT&quot;);
	graph = p; n = p.size(); res.resize(n);
	for(int i=0;i&lt;n;i++) res[i].resize(n);
	for(int i=0;i&lt;n;i++) {
		if(vis[i]) continue;
		ma = 1; block.clear(); dfs(i);
//		printf(&quot;ROUND %d DFS ENDED WITH MAX=%d\n&quot;, i, ma);
		if(ma == 3) return 0;
		int sz = block.size();
		for(int j=1;j&lt;sz;j++) {
			for(int k=0;k&lt;j;k++) {
				if(!graph[block[j]][block[k]]) return 0;
			}
		}
		if(ma == 1) for(int j=1;j&lt;sz;j++) add(block[0], block[j]);
		else {
			circle.clear();
			for(int _=0,j=block[_];_&lt;sz;_++,j=block[_]) {
				if(vis[j] != 1) continue;
				edge.clear();
				dfsCircle(j);
//				puts(&quot;DFSCIRCLE ENDED&quot;);
				int sz2 = edge.size();
				for(int k=1;k&lt;sz2;k++) {
					for(int l=0;l&lt;k;l++) {
						if(graph[edge[k]][edge[l]] != 1) return 0;
					}
					add(edge[0], edge[k]);
				}
				circle.push_back(edge[0]);
//				printf(&quot;CIRCLE ADDED %d\n&quot;, edge[0]);
			}
			if(circle.size() &lt;= 2) return 0;
			int sz3 = circle.size();
			for(int j=0;j&lt;sz3;j++) add(circle[j], circle[(j+1)%sz3]);
		}
	}
	build(res);
	return 1;
}/*

void build(vector&lt;vector&lt;int&gt; &gt; b) {
	puts(&quot;BUILD&quot;);
	for(int i=0;i&lt;b.size();i++) {
		for(int j=0;j&lt;b[i].size();j++) printf(&quot;%d &quot;, b[i][j]);
		puts(&quot;&quot;);
	}
}
int main() {
	vector&lt;vector&lt;int&gt; &gt; a = vector&lt;vector&lt;int&gt; &gt;
							({vector&lt;int&gt;({1, 1, 2, 2}), vector&lt;int&gt;({1, 1, 2, 2})
							, vector&lt;int&gt;({2, 2, 1, 2}), vector&lt;int&gt;({2, 2, 2, 1})});
	build(a);
	printf(&quot;CONSTRUCT ENDED WITH RETURN VALUE %d\n&quot;, construct(a));
	return 0;
}*/
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF441C@洛谷 | 441C@Codeforces 【Valera and Tubes 】]]></title>
        <id>https://blog.ak-ioi.cf/post/solution-luogu-cf441c-codeforces-441c/</id>
        <link href="https://blog.ak-ioi.cf/post/solution-luogu-cf441c-codeforces-441c/">
        </link>
        <updated>2020-10-05T05:57:16.000Z</updated>
        <content type="html"><![CDATA[<p><strong>upd(2020.10.5)：修复一个手贱错误。</strong></p>
<p>题意：一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m\times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的网格图，每次连一条线，要求这条线：</p>
<ul>
<li>至少包含两个点。</li>
<li>必须连续：也就是说，每一步可以继续向前画，也可以向左或向右转弯 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>90</mn><mi mathvariant="normal">°</mi></mrow><annotation encoding="application/x-tex">90\degree</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">0</span><span class="mord">°</span></span></span></span>。</li>
<li>不与以前画过的线重复。</li>
</ul>
<p>构造一种包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 条线的画法，把整个图覆盖。</p>
<hr>
<p>显然构造题。</p>
<p>一种容易想到的方法是：我们使前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 条线每条经过两个点，最后一条线将剩余所有点连接。为了方便描述，我们以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mo>×</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">5\times 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 的网格图为例，对其进行编号：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/nerfbeur.png" alt="" loading="lazy"></figure>
<p>假设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">k=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>，则四条线段分别经过如下点：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Line</mi><mo>⁡</mo><mn>1</mn><mo>:</mo><mo>(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Line}1:(1,2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mop"><span class="mord mathrm">L</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">e</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Line</mi><mo>⁡</mo><mn>2</mn><mo>:</mo><mo>(</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Line}2:(3,4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mop"><span class="mord mathrm">L</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">e</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Line</mi><mo>⁡</mo><mn>3</mn><mo>:</mo><mo>(</mo><mn>5</mn><mo separator="true">,</mo><mn>6</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Line}3:(5,6)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mop"><span class="mord mathrm">L</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">e</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">)</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Line</mi><mo>⁡</mo><mn>4</mn><mo>:</mo><mo>(</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mn>25</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">\operatorname{Line}4:(7,8,\cdots,25)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mop"><span class="mord mathrm">L</span><span class="mord mathrm">i</span><span class="mord mathrm">n</span><span class="mord mathrm">e</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>基础思路有了，问题转化为如何根据点的编号求出其坐标。发现对于奇数行，编号正序；偶数行为倒序。我们根据这一特点对编号的行数进行分类，经过一定的数学推导，就可以得到行数和列数了。</p>
<pre><code class="language-cpp">pair&lt;int, int&gt; calcPos(int x) {
	int div = (x - 1) / n + 1, pos = (x - 1) % n + 1;
	if(div &amp; 1) return make_pair(div, pos);
	return make_pair(div, n-pos+1);
}
</code></pre>
<p>然后根据上面说过的思路，计算出所有线的情况，输出即可。</p>
<hr>
<p>代码：</p>
<pre><code class="language-cpp">//By: Luogu@rui_er(122461)
#include &lt;bits/stdc++.h&gt;
using namespace std;

int n, m, k;
pair&lt;int, int&gt; calcPos(int x) {
	int div = (x - 1) / n + 1, pos = (x - 1) % n + 1;
	if(div &amp; 1) return make_pair(div, pos);
	return make_pair(div, n-pos+1);
}

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;m, &amp;n, &amp;k);
	for(int i=1;i&lt;k;i++) {
		printf(&quot;2 &quot;);
		pair&lt;int, int&gt; _;
		_ = calcPos((i&lt;&lt;1)-1);
		printf(&quot;%d %d &quot;, _.first, _.second);
		_ = calcPos(i&lt;&lt;1);
		printf(&quot;%d %d\n&quot;, _.first, _.second);
	}
	printf(&quot;%d &quot;, n*m-((k-1)&lt;&lt;1));
	for(int i=(k&lt;&lt;1)-1;i&lt;=n*m;i++) {
		pair&lt;int, int&gt; _;
		_ = calcPos(i);
		printf(&quot;%d %d &quot;, _.first, _.second);
	}
	puts(&quot;&quot;);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[块状数组&莫队学习笔记]]></title>
        <id>https://blog.ak-ioi.cf/post/lxl-ds-txdy/</id>
        <link href="https://blog.ak-ioi.cf/post/lxl-ds-txdy/">
        </link>
        <updated>2020-10-04T10:49:15.000Z</updated>
        <content type="html"><![CDATA[<p>本博客从入门级到 Ynoi 全覆盖 <s>（确信）</s>，欢迎评论、点赞、转发！（日常营销号）</p>
<p>如果以下内容有错误，欢迎指出！转载全文或部分前请先联系作者。</p>
<p>同步发布于<a href="https://www.luogu.com.cn/blog/ak-ioi/lxl-ds-txdy">洛谷博客</a>。</p>
<hr>
<h1 id="0x1-分块块状数组">0x1 分块&amp;块状数组</h1>
<p>分块，顾名思义，就是将原数列分成若干块（一般取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span> 左右，可以动态也可以取常数），进行的快速统计的方法。块状数组类似于线段树，维护区间的信息。</p>
<h2 id="例题-1p3372-模板线段树-1">例题 1：<a href="/problem/P3372">P3372 【模板】线段树 1</a></h2>
<p>（好好写线段树它不香吗）</p>
<p>由于块状数组的复杂度不正确，不保证此做法能在<strong>任意时刻</strong>通过此题，仅以此题为例讲解思路。</p>
<p>AC 记录：<a href="/record/39258823">线段树</a> | <a href="/record/39259550">分块</a></p>
<p>我们将原数列分成块长为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>320</mn></mrow><annotation encoding="application/x-tex">320</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">0</span></span></span></span> 的若干个块，对于每一块，我们记录一个<code>块内的和</code>和一个<code>懒标记</code>。修改时，若左右端点在同一块，直接暴力修改原数组和分块；若不在同一块，暴力修改左右零散块，中间整块修改<code>块内的和</code>以及<code>懒标记</code>。查询时类似，记得懒标记下放。</p>
<p>时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><msqrt><mi>n</mi></msqrt><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n\sqrt{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>容易写出代码：</p>
<pre><code class="language-cpp">//By: Luogu@rui_er(122461)
#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const ll N = 1e5+5, SIZE = 320, K = 320;

ll n, m, a[N], s[K], tag[K], L[K], R[K], tot;
#define whichBlock(x) (\
	(x-1)/SIZE+1\
)
void initBlock() {
	tot = whichBlock(n);
	for(ll i=1;i&lt;=tot;i++) {
		L[i] = R[i-1] + 1;
		R[i] = i * SIZE;
		for(ll j=L[i];j&lt;=min(R[i],n);j++) s[i] += a[j];
	}
	R[tot] = n;
}
void pushdown(ll u) {
	ll X = whichBlock(u);
	if(!tag[X]) return;
	for(ll i=L[X];i&lt;=R[X];i++) a[i] += tag[X];
	tag[X] = 0;
}
void modify(ll l, ll r, ll k) {
	ll X = whichBlock(l), Y = whichBlock(r);
	if(X == Y) for(ll i=l;i&lt;=r;i++) a[i] += k, s[X] += k;
	else {
		for(ll i=l;i&lt;=R[X];i++) a[i] += k, s[X] += k;
		for(ll i=X+1;i&lt;Y;i++) tag[i] += k, s[i] += (R[i] - L[i] + 1) * k;
		for(ll i=L[Y];i&lt;=r;i++) a[i] += k, s[Y] += k;
	}
}
ll query(ll l, ll r) {
	ll X = whichBlock(l), Y = whichBlock(r), ans = 0;
	if(X == Y) {
		pushdown(l);
		for(ll i=l;i&lt;=r;i++) ans += a[i];
	}
	else {
		pushdown(l);
		for(ll i=l;i&lt;=R[X];i++) ans += a[i];
		for(ll i=X+1;i&lt;Y;i++) ans += s[i];
		pushdown(r);
		for(ll i=L[Y];i&lt;=r;i++) ans += a[i];
	}
	return ans;
}

int main() {
	scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
	for(ll i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;, &amp;a[i]);
	initBlock();
	while(m--) {
		ll op, l, r, x;
		scanf(&quot;%lld%lld%lld&quot;, &amp;op, &amp;l, &amp;r);
		if(op == 1) {
			scanf(&quot;%lld&quot;, &amp;x);
			modify(l, r, x);
		}
		else printf(&quot;%lld\n&quot;, query(l, r));
	}
	return 0;
}
</code></pre>
<p>【完结撒花！】</p>
<p>其实分块大概就是这样，基础部分练习完了，我们来看几道习题。</p>
<p>部分习题有题解，不做额外讲解；其他的大概提思路。</p>
<h2 id="习题-1p5309-ynoi2011初始化-题解">习题 1：<a href="/problem/P5309">P5309 [Ynoi2011]初始化</a> | <a href="/blog/ak-ioi/solution-p5309">题解</a></h2>
<h2 id="习题-2p5356-ynoi2017由乃打扑克-题解">习题 2：<a href="/problem/P5356">P5356 [Ynoi2017]由乃打扑克</a> | <a href="/blog/ak-ioi/solution-p5356">题解</a></h2>
<h1 id="0x2-莫队">0x2 莫队</h1>
<h2 id="例题-1p1972-sdoi2009hh的项链">例题 1：<a href="/problem/P1972">P1972 [SDOI2009]HH的项链</a></h2>
<p>不过这题好像把莫队卡了，那就好好用树状数组吧。</p>
<p>没关系，我们有双倍经验。</p>
<h2 id="例题-15sp3267-dquery-d-query">例题 1.5：<a href="/problem/SP3267">SP3267 DQUERY - D-query</a></h2>
<p>统计区间内颜色个数，怎么办呢？</p>
<p>我们考虑暴力。每次暴力统计一遍太费时间了，我们搞两个指针，表示当前统计到的区间，然后在用一个数组存每个颜色在区间内有多少个，一个变量存区间内有多少颜色即可。统计到下一个区间，我们移动这两个指针（实时更新数组内的值），通过上面提到的数组来更新变量（颜色）的值。</p>
<p>但是这样很容易被卡：询问 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mi>n</mi><mo separator="true">,</mo><mi>n</mi><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo>]</mo><mo separator="true">,</mo><mo>[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">[1,1],[n,n],[2,2],[n-1,n-1]\cdots</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span></span></span></span> 效率明显低下。怎么办呢？离线做法，先对询问进行排序！</p>
<p>排序的伪代码：</p>
<pre><code class="language-text">结构体 Query {int l, r, id;}
比较(Query a, Query b):
    如果 a.l 与 b.l 在同一块中:
        比较 a.r 与 b.r 并返回
    否则：
        比较 a.l 与 b.l 并返回
</code></pre>
<p>在排序后，这个算法的效率是更高的，可以算出复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><msqrt><mi>n</mi></msqrt><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n\sqrt{n})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.05028em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p>
<p>（写作时间紧张，复杂度证明先咕了，改天再加）</p>
<h2 id="例题-2p2709-小b的询问">例题 2：<a href="/problem/P2709">P2709 小B的询问</a></h2>
<p>统计区间内不同数的个数的平方和，与上面类似，采用莫队。</p>
<pre><code class="language-cpp">//By: Luogu@rui_er(122461)
#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 5e4+5, SIZE = 250;

int n, m, k, a[N], tot, s[N], ans[N];
#define whichBlock(x) (\
	(x-1)/SIZE+1\
)
struct Node {
	int l, r, id;
	friend bool operator &lt; (const Node &amp;a, const Node &amp;b) { // 排序方法
		int x = whichBlock(a.l), y = whichBlock(b.l);
		if(x == y) return a.r &lt; b.r;
		return x &lt; y;
	}
}q[N];

void modify(int x, int y) { // 莫队指针移动更新数据
	int z = a[x];
	tot -= s[z] * s[z];
	s[z] += y;
	tot += s[z] * s[z];
}

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
	for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;, &amp;a[i]);
	for(int i=1;i&lt;=m;i++) {
		scanf(&quot;%d%d&quot;, &amp;q[i].l, &amp;q[i].r);
		q[i].id = i;
	}
	sort(q+1, q+1+m);
	int l = 1, r = 0;
	for(int i=1;i&lt;=m;i++) {
		while(l &lt; q[i].l) modify(l++, -1); // 移动指针
		while(l &gt; q[i].l) modify(--l, 1);
		while(r &lt; q[i].r) modify(++r, 1);
		while(r &gt; q[i].r) modify(r--, -1);
		ans[q[i].id] = tot;
	}
	for(int i=1;i&lt;=m;i++) printf(&quot;%d\n&quot;, ans[i]);
	return 0;
}
</code></pre>
<h2 id="习题-1p1494-国家集训队小z的袜子">习题 1：<a href="/problem/P1494">P1494 [国家集训队]小Z的袜子</a></h2>
<p>小Z的<s>妹子</s>袜子这题需要一定的数学推导，和上面那题类似，也需要维护区间平方和。</p>
<h2 id="习题-2p4688-ynoi2016掉进兔子洞-题解">习题 2：<a href="/problem/P4688">P4688 [Ynoi2016]掉进兔子洞</a> | <a href="/blog/ak-ioi/solution-p4688">题解</a></h2>
<p>用 bitset 套莫队即可。</p>
<hr>
<p>完结撒花！</p>
<p>带修莫队和树上莫队因为自己还没做所以先不写了，以后会写新博客更新的~</p>
<p><s>（话说我这么用 Ynoi 当习题会不会被打）</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P4688@洛谷 【[Ynoi2016]掉进兔子洞】]]></title>
        <id>https://blog.ak-ioi.cf/post/solution-luogu-p4688/</id>
        <link href="https://blog.ak-ioi.cf/post/solution-luogu-p4688/">
        </link>
        <updated>2020-10-03T15:04:52.000Z</updated>
        <content type="html"><![CDATA[<p>题意已经足够清楚了，我们直接说思路：</p>
<hr>
<p>前置知识：</p>
<ul>
<li>分块、莫队</li>
<li>离散化</li>
<li>一些奇奇怪怪的技巧</li>
</ul>
<p>根据题意三段区间的数的总和为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>3</mn></msubsup><mo>(</mo><msub><mi>r</mi><mi>i</mi></msub><mo>−</mo><msub><mi>l</mi><mi>i</mi></msub><mo>+</mo><mn>1</mn><mo>)</mo><mo>−</mo><mn>3</mn><mo>×</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\sum_{i=1}^3(r_i-l_i+1)-3\times k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.253718em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 为三段区间内共有的数的个数。问题转化为求这个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的值。</p>
<p>容易想到，我们使用莫队维护查询的区间内每个数的个数。对于一次询问，我们将其拆成传统莫队的三个询问：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>l</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>1</mn></msub><mo>)</mo><mo separator="true">,</mo><mo>(</mo><msub><mi>l</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>2</mn></msub><mo>)</mo><mo separator="true">,</mo><mo>(</mo><msub><mi>l</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>r</mi><mn>3</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(l_1,r_1),(l_2,r_2),(l_3,r_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，分别进行处理。我们要得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，需要得到这三个询问中有哪些数、分别几个，然后取它们的交集即可。</p>
<p>那么问题来了，这个交集（或三次询问）怎么求呢？注意一个数可能重复出现多次。我们考虑先将初始 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 数组进行<strong>离散化</strong>，只记录 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 数组每一个值对应排序好的数组的<strong>编号</strong>即可。这样，若干个相同的数便会留出若干个空着的编号，它们代表同一个值。然后使用这个离散化的对应关系用 bitset 存即可。</p>
<p>完结撒花！</p>
<p>等等，Ynoi 可不是这么简单就过去的。看一眼数据范围，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo>≤</mo><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">1\le n,m\le 10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。bitset 存不下！（笑容逐渐凝固）</p>
<p>没关系，我们可以把输入的查询<strong>分为若干组</strong>，每组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">2\times 10^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> 个数（当然更大也可以，不炸空间就没事），对于每一组分别进行处理即可。</p>
<p><strong>小细节：莫队必须先进队再出队！</strong> 我因为一开始顺序搞混一直 RE，被卡了 1.5h！</p>
<p>真·完结撒花！</p>
<hr>
<p>主要代码：</p>
<pre><code class="language-cpp">const ll N = 1e5+5, M = 2e4, K = M+5, SIZE = 320;
ll n, m, a[N], b[N], s[N];
ll vis[N], len[N];
bitset&lt;N&gt; cnts[K], u;
#define whichBlock(x) (\
	(x-1)/SIZE+1\
)
struct Node {
	ll l, r, id;
	friend bool operator &lt; (const Node &amp;a, const Node &amp;b) {
		ll x = whichBlock(a.l), y = whichBlock(b.l);
		if(x == y) return a.r &lt; b.r;
		return x &lt; y;
	}
}q[N];

void discretization() {
	for(ll i=1;i&lt;=n;i++) {
		scanf(&quot;%lld&quot;, &amp;a[i]);
		b[i] = a[i];
	}
	sort(b+1, b+1+n);
	for(ll i=1;i&lt;=n;i++) a[i] = ll(lower_bound(b+1, b+1+n, a[i]) - b);
}
void modify(ll x, ll y) {
	ll z = a[x];
	if(y == -1) u[z+(--s[z])] = 0;
	else u[z+(s[z]++)] = 1;
}
void solve(ll op) {
	assert(op &gt; 0);
	ll tot = 0;
	memset(s, 0, sizeof(s));
	for(ll i=1;i&lt;=op;i++) {
		vis[i] = len[i] = 0;
		for(ll j=1;j&lt;=3;j++) {
			q[++tot].id = i;
			scanf(&quot;%lld%lld&quot;, &amp;q[tot].l, &amp;q[tot].r);
			len[i] += q[tot].r - q[tot].l + 1;
		}
	}
	sort(q+1, q+1+tot);
	ll l = 1, r = 0;
	u.reset();
	for(ll i=1;i&lt;=tot;i++) {
		while(l &gt; q[i].l) modify(--l, 1);
		while(r &lt; q[i].r) modify(++r, 1);
		while(l &lt; q[i].l) modify(l++, -1);
		while(r &gt; q[i].r) modify(r--, -1);
		if(vis[q[i].id]) cnts[q[i].id] &amp;= u;
		else cnts[q[i].id] = u;
		vis[q[i].id] = 1;
	}
	for(ll i=1;i&lt;=op;i++) printf(&quot;%lld\n&quot;, len[i]-3*(ll)cnts[i].count());
}
</code></pre>
]]></content>
    </entry>
</feed>