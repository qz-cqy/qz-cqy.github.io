<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.ak-ioi.cf</id>
    <title>rui_er 的博客</title>
    <updated>2021-02-06T11:07:04.869Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.ak-ioi.cf"/>
    <link rel="self" href="https://blog.ak-ioi.cf/atom.xml"/>
    <subtitle>三思而后码</subtitle>
    <logo>https://blog.ak-ioi.cf/images/avatar.png</logo>
    <icon>https://blog.ak-ioi.cf/favicon.ico</icon>
    <rights>All rights reserved 2021, rui_er 的博客</rights>
    <entry>
        <title type="html"><![CDATA[NOI WC2021 游记]]></title>
        <id>https://blog.ak-ioi.cf/post/i-ak-noi-wc2021/</id>
        <link href="https://blog.ak-ioi.cf/post/i-ak-noi-wc2021/">
        </link>
        <updated>2021-02-06T11:05:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p><strong>CCF 宣传片语录镇楼：</strong></p>
<p><strong>假设有 l 到 r，这是 l，这是 r。这些边我不加。这些边我不加！暴力怎么做？暴力是不是，加边、加边、加边，然后，并查集查询。</strong></p>
<ul>
<li>NOI WC2020 “冬”令营 &amp; 夏令营，<s>嫌太贵</s>没有报名，看到有些同学拿到了铜牌非常羡慕。</li>
<li>APIO2020 报名了 B 类参赛，但是因为做题策略原因爆零打铁，有些同学又拿到了铜牌。<a href="/blog/ak-ioi/i-ak-apio2020">游记</a></li>
<li>CSP2020 提高级挂了将近 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>100</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 分，只获得了六级分数线+一等奖。</li>
<li>NOIP2020 挂了不知道多少分，沦为 2= 人。</li>
</ul>
<p>（备注：初二年级，第一次 WC）</p>
<h1 id="20201224-2459208">2020.12.24 | 2459208</h1>
<p>看到了官网的通知，准备报名。问了半天老师说过几天发一个问卷统一报名。</p>
<h1 id="20201226-2459210">2020.12.26(?) | 2459210(?)</h1>
<p>催完老师了，报名成功 /cy。</p>
<h1 id="202111-2459216">2021.1.1 | 2459216</h1>
<p>报名成功了，进微信群了 qaq，祝我成功拿到 Cu。</p>
<h1 id="2021129-2459244">2021.1.29 | 2459244</h1>
<p>下午 15:00 进会议室，看了亿遍 CCF 宣传片，还截到了 3M 原则的三张图片（</p>
<h1 id="2021131-2459246">2021.1.31 | 2459246</h1>
<p>被 ClCN 在群里拍了，于是就知道了 ClCN 的真名（危</p>
<p>然后在犇犇说了一下，于是不知道多少人知道了我的真名（当然也可能没注意）</p>
<p>然后转眼就看到 ClCN 拍了何琳（危</p>
<h1 id="202121-2459247">2021.2.1 | 2459247</h1>
<p>本来以为开幕式会半小时，结果只有 7 分钟。。。</p>
<p>想进第一课堂但发现课件都看不懂，果断去第二课堂。</p>
<p>上午听懂了一些 dp 模型和优化，这很好。</p>
<p><s>下午听懂了如何从同学/家长那里骗钱，这非常好！！！11</s></p>
<h1 id="202122-2459248">2021.2.2 | 2459248</h1>
<p>上午听课把网络流复习了一遍，感觉还不错。</p>
<p><s>记住了老师名言：我们是不是只要在下午的课前下课就行了？</s></p>
<p>下午加边老师（？）讲课，听懂了基础的字符串，exKMP 和 SA 后面的有点晕，但还是学会了一些东西的。</p>
<h1 id="202123-2459249">2021.2.3 | 2459249</h1>
<p>上午讲树论，于是前面听懂了，后面定义和板子都不讲就一句“打板子就可以了”直接带过，成功的导致了我原来会的依然会、原来不会的依然不会，于是听到点分治实在忍不住了直接退直播间。</p>
<p>下午第一课堂 IOI+，第二课堂 pj-，于是啥都没听就跑去<s>颓废</s>写文化课。</p>
<h1 id="202124-2459250">2021.2.4 | 2459250</h1>
<p>上午跑去第一课堂听了半天 MO 课 &amp; 希腊语课，下午讲多线程和并行计算懒得听。</p>
<h1 id="202125-2459251">2021.2.5 | 2459251</h1>
<p>早上 7:30 起来了，又去看了一眼 CCF 通知，才发现考试是 8:30 开始而不是 8:00，于是就来洛谷背板子，背了一下网络流、模拟退火、二维凸包，结果啥都没用上。</p>
<p>先把所有题看了一遍，最后决定打暴力顺序 T2→T3→T1。T2、T3 直接打的暴力，T1 暴力打的一点都不顺利，调了好久搞了个玄学做法，但一直 hack 不掉（可能因为我手算太麻烦搞得全特别小），最后放弃。</p>
<p>线上赛，具体过程没啥好描述的，放张图：</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/31i46gsk.png" alt="" loading="lazy"></figure>
<p>最后跟同学说了一下估分，发现我们几个好像差不多，这是我的垃圾估分：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">(</mo><mn>0</mn><mo>∼</mo><mn>32</mn><mo fence="true">)</mo></mrow><mo>+</mo><mrow><mo fence="true">(</mo><mn>35</mn><mo>∼</mo><mn>50</mn><mo fence="true">)</mo></mrow><mo>+</mo><mn>20</mn><mo>=</mo><mn>55</mn><mo>∼</mo><mn>102</mn></mrow><annotation encoding="application/x-tex">\left(0\sim 32\right)+\left(35\sim 50\right)+20=55\sim 102</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">3</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span></span></span></span></li>
</ul>
<p>不知道有没有写挂，希望能拿个牌牌 qaq。</p>
<p>然后下午听讲题，说 T1 思路就是加边加边加边并查集查询，<s>CCF 宣传片泄题建议禁三！！！11</s></p>
<p>其他的大概听了下，果然我还是太菜了。</p>
<p>第一次 NOIWC 完结撒花，成绩等出来再说（</p>
<h1 id="202126-2459252">2021.2.6 | 2459252</h1>
<p>分数线 70/118/158，打铁祭（（（虽然还不知道我多少</p>
<p>upd：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn><mo>+</mo><mn>35</mn><mo>+</mo><mn>20</mn><mo>=</mo><mn>87</mn></mrow><annotation encoding="application/x-tex">32+35+20=87</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span><span class="mord">7</span></span></span></span>，拿到了铜牌牌 awa</p>
<p>吐槽一句，今年分数线咋比去年高那么多啊 /kel</p>
<p>总结：</p>
<ul>
<li>第一次 WC 拿到 Cu 还是很惊喜的，但是跟同学最高分还是差了 18 分，果然还是我太菜了，【同学真名】txdy！！！！！！！11</li>
<li>暴力出奇迹，要仔细审题，不要漏掉取模啥的，把能拿到的部分分都拿了，少失误（</li>
<li>没了，因为我太菜了。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P1175@洛谷 【表达式的转换】]]></title>
        <id>https://blog.ak-ioi.cf/post/solution-luogu-p1175/</id>
        <link href="https://blog.ak-ioi.cf/post/solution-luogu-p1175/">
        </link>
        <updated>2021-01-22T14:17:38.000Z</updated>
        <content type="html"><![CDATA[<p>本题题解貌似已经比较多了，但是我在本题卡了一段时间，写出了好几处错误，因此写一篇题解梳理一下思路。</p>
<p>题意：模拟 <code>+-*/^()</code> 以及数字初始为一位数的后缀表达式运算过程。</p>
<p><strong>注意这里有一个运算符 <code>^</code>，我一开始就没有注意到，然后样例也没有，硬是对着代码和题面看了半天才发现！</strong></p>
<hr>
<p>思路：</p>
<p>模拟。先转化为后缀表达式，再模拟运算过程，逐步求解。</p>
<p><strong>子问题一：中缀表达式转后缀表达式。</strong></p>
<p>我们考虑运算符的优先级，可以对于每个运算符给定一个数为优先级，方便后续比较。这里，我设置的优先级为：</p>
<pre><code class="language-cpp">int priority(char c) {
	if(c == '^') return 3;
	if(c == '*' || c == '/') return 2;
	if(c == '+' || c == '-') return 1;
	if(c == '(' || c == ')') return 0;
	throw &quot;WA! Unexpected operator&quot;;
}
</code></pre>
<p>其中 throw 行是为了防止出现错误添加的异常，实际上也并没有进行处理，可以忽略。</p>
<p>然后考虑转化，遍历原字符串每一位，按照如下规则处理：</p>
<ul>
<li>如果是数字，直接输出到后缀表达式。</li>
<li>如果是左括号 <code>(</code>，可以压进符号栈中。</li>
<li>如果是右括号 <code>)</code>，将符号栈中符号弹出到后缀表达式，直到遇到第一个左括号 <code>(</code>，并将其弹出。</li>
<li>如果是乘方 <code>^</code>，可以压进符号栈中。</li>
<li>如果是加减乘除 <code>+-*/</code>，利用上面的优先级，将符号栈中符号弹出到后缀表达式，直到遇到第一个优先级低于（不含）它的符号，然后将其压进符号栈。</li>
</ul>
<p>那么问题来了，怎么存储后缀表达式呢？这里我使用了一个结构体 <code>struct</code>，一个指示变量表示这个是数字还是符号，一个联合体 <code>union</code> 来存储具体内容，然后使用向量容器 <code>vector</code> 来按顺序存储后缀表达式。</p>
<p>结构体定义和转换后缀表达式部分代码如下：</p>
<pre><code class="language-cpp">struct Node {
	int type;
	union {
		int x;
		char op;
	}data;
	Node() {}
	Node(int x) : type(1) {data.x = x;}
	Node(char c) : type(0) {data.op = c;}
};
void toSuffix() {
	rep(i, 0, n-1) {
		if(isdigit(c[i])) v.push_back(Node(int(c[i]^'0')));
		else {
			if(c[i] == '(') op.push(c[i]);
			else if(c[i] == ')') {
				while(op.top() != '(') {
					v.push_back(Node(char(op.top())));
					op.pop();
				}
				op.pop();
			}
			else if(c[i] == '^') op.push(c[i]);
			else {
				while(!op.empty() &amp;&amp; priority(op.top()) &gt;= priority(c[i])) {
					v.push_back(Node(char(op.top())));
					op.pop();
				}
				op.push(c[i]);
			}
		}
	}
	while(!op.empty()) {
		v.push_back(Node(char(op.top())));
		op.pop();
	}
}
</code></pre>
<p><strong>子问题二：模拟运算步骤得出结果。</strong></p>
<p>这部分比较简单，做过 <a href="/problem/P1449">P1449 后缀表达式</a> 的同学都应该基本会了。我们按顺序读取后缀表达式内存储的数据，如果是数字则压入数字栈，否则弹出两个数字做运算后压回。<strong>注意运算的顺序，应该是第二个弹出的数作为被减数（加数、乘数、被除数、底数），第一个弹出的数作为减数（加数、乘数、除数、指数）！</strong></p>
<p>然后每处理一个运算符，输出一次即可。</p>
<p>这部分代码：</p>
<pre><code class="language-cpp">void prtall() {
	int sz = v.size();
	rep(i, 0, sz-1) {
		if(v[i].type) printf(&quot;%d%c&quot;, v[i].data.x, &quot; \n&quot;[i==sz-1]);
		else printf(&quot;%c%c&quot;, v[i].data.op, &quot; \n&quot;[i==sz-1]);
	}
}
void prtsec(int u) {
	int sz = v.size();
	while(!s.empty()) {t.push(s.top()); s.pop();}
	while(!t.empty()) {printf(&quot;%d &quot;, t.top()); s.push(t.top()); t.pop();}
	rep(i, u, sz-1) {
		if(v[i].type) printf(&quot;%d &quot;, v[i].data.x);
		else printf(&quot;%c &quot;, v[i].data.op);
	}
	puts(&quot;&quot;);
}
void calc() {
	prtall();
	int sz = v.size();
	rep(i, 0, sz-1) {
		if(v[i].type) s.push(v[i].data.x);
		else {
			int a, b; char _;
			b = s.top(); s.pop();
			a = s.top(); s.pop();
			_ = v[i].data.op;
			if(_ == '+') s.push(a+b);
			else if(_ == '-') s.push(a-b);
			else if(_ == '*') s.push(a*b);
			else if(_ == '/') s.push(a/b);
			else s.push(qpow(a, b));
			prtsec(i+1);
		}
	}
}
</code></pre>
<p>这就是本题的主体代码，我也取得了 AC，代码长度 107 行、共 2441 个字符（本地统计），可以算是一个中模拟。</p>
<p>由于主要代码在上面都贴过了，为了防止影响篇幅和版面，将完整代码放到 <a href="/paste/713luey5">云剪贴板</a>。</p>
<p>完结撒花！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF156B@洛谷 | 156B@Codeforces 【Suspects】]]></title>
        <id>https://blog.ak-ioi.cf/post/solution-luogu-cf156b-codeforces-156b/</id>
        <link href="https://blog.ak-ioi.cf/post/solution-luogu-cf156b-codeforces-156b/">
        </link>
        <updated>2021-01-20T11:11:05.000Z</updated>
        <content type="html"><![CDATA[<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个人中有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个罪犯，每个人说一句话，说第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 个人是/不是罪犯，其中有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 句真话，要判断这些话的真假。</p>
<p>思路：</p>
<p>首先假设所有人都不是罪犯，统计出真话条数，然后枚举每一个人，在这个真话条数的基础上加上这个人是罪犯时对答案的贡献，如果刚好有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 句真话，标记有嫌疑，最后判断即可。</p>
<p>但是这个贡献怎么求呢？</p>
<p>很简单，如果所有人都不是罪犯，则真话条数就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a_i\lt 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 的数量；当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 是罪犯时，减去 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">a_i=-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord mathdefault">x</span></span></span></span> 的数量，加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">a_i=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的数量，即为最新的贡献，这里在读入时也处理出来。</p>
<p>最后话的真假的判断方式也很简单：</p>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 指控一个人是罪犯：经过如上处理，发现他不可能是罪犯，则为假话；如果他可能是罪犯且嫌疑人数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，则为真话；否则不确定。说一个人不是罪犯的情况类似，不展开细说，可以参考代码。</p>
<hr>
<p>代码：</p>
<pre><code class="language-cpp">//By: Luogu@rui_er(122461)
#include &lt;bits/stdc++.h&gt;
#define loop while(true)
#define rep(x,y,z) for(int x=y;x&lt;=z;x++)
#define per(x,y,z) for(int x=y;x&gt;=z;x--)
#define fil(x,y) memset(x, y, sizeof(x))
#define mulT0 int T; for(scanf(&quot;%d&quot;, &amp;T);T;T--)
#define mulT1 int T, rnds; for(scanf(&quot;%d&quot;, &amp;T),rnds=1;rnds&lt;=T;rnds++)
using namespace std;
typedef long long ll;
const int N = 1e5+5;

int n, m, a[N], contribution[N], suspect[N], tot, s;

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	rep(i, 1, n) {
		scanf(&quot;%d&quot;, &amp;a[i]);
		if(a[i] &gt; 0) ++contribution[a[i]];
		else --contribution[-a[i]], ++s;
	}
	rep(i, 1, n) if(s + contribution[i] == m) suspect[i] = 1, ++tot;
	rep(i, 1, n) {
		if(a[i] &gt; 0) {
			if(!suspect[a[i]]) puts(&quot;Lie&quot;);
			else if(tot == 1) puts(&quot;Truth&quot;);
			else puts(&quot;Not defined&quot;);
		}
		else {
			if(!suspect[-a[i]]) puts(&quot;Truth&quot;);
			else if(tot == 1) puts(&quot;Lie&quot;);
			else puts(&quot;Not defined&quot;);
		}
	}
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF128D@洛谷 | 128D@Codeforces 【Numbers】]]></title>
        <id>https://blog.ak-ioi.cf/post/solution-luogu-cf128d-codeforces-128d/</id>
        <link href="https://blog.ak-ioi.cf/post/solution-luogu-cf128d-codeforces-128d/">
        </link>
        <updated>2021-01-18T10:51:17.000Z</updated>
        <content type="html"><![CDATA[<p>简单构造题。</p>
<p>题意：给定 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个数，是否能排成一圈，使相邻两个数差 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<hr>
<p>根据题意，为了使相邻两个数差 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，圆圈中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 的次数必定相等才能组成闭环，因此 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 必须是偶数，对于奇数可以直接输出无解（代码注释 <code>{1}</code>）。</p>
<p>然后同样根据相邻两个数差 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的性质，我们将原数列排序，枚举相邻两个下标的数，如果差大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 也输出无解（代码注释 <code>{2}</code>）。</p>
<p>之后找到数列最小值，把每个数减去最小值再加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，即可得到一串与原数列等效的、最小值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的数列，经过前面两个特判，可以保证最大值不超过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">10^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>。然后从最小值开始，可以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span> 时选择 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">+</span><span class="mord">1</span></span></span></span>，否则看看是否可以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>，若不可以就跳出循环。</p>
<p>由于闭环性质，要形成环则最后一个数必定是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span>，如果不是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 则不能成环，输出无解（代码注释 <code>{3}</code>）。</p>
<p>否则将整个桶扫一遍，如果有地方不为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 则代表成环失败，输出无解（代码注释 <code>{4}</code>）。</p>
<p>否则即代表我们构造出了一个符合题意的环，输出有解即可。</p>
<p>这样就水过了一道 CF <code>*2000</code> 的构造题（</p>
<hr>
<p>代码：</p>
<pre><code class="language-cpp">//By: Luogu@rui_er(122461)
#include &lt;bits/stdc++.h&gt;
#define loop while(true)
#define rep(x,y,z) for(int x=y;x&lt;=z;x++)
#define per(x,y,z) for(int x=y;x&gt;=z;x--)
#define fil(x,y) memset(x, y, sizeof(x))
#define mulT0 int T; for(scanf(&quot;%d&quot;, &amp;T);T;T--)
#define mulT1 int T, rnds; for(scanf(&quot;%d&quot;, &amp;T),rnds=1;rnds&lt;=T;rnds++)
using namespace std;
typedef long long ll;
const int N = 1e5+5, inf = 1e9;

int n, a[N], buc[N], mi = inf;

int main() {
	scanf(&quot;%d&quot;, &amp;n);
	if(n &amp; 1) return puts(&quot;NO&quot;), 0; // {1}
	rep(i, 1, n) scanf(&quot;%d&quot;, &amp;a[i]), mi = min(mi, a[i]);
	sort(a+1, a+1+n);
	rep(i, 2, n) if(a[i] - a[i-1] &gt; 1) return puts(&quot;NO&quot;), 0; // {2}
	rep(i, 1, n) ++buc[a[i]-mi+1];
	int u = 1; --buc[1];
	loop {
		if(buc[u+1]) --buc[++u];
		else if(buc[u-1]) --buc[--u];
		else break;
	}
	if(u != 2) return puts(&quot;NO&quot;), 0; // {3}
	rep(i, 0, N-1) if(buc[i]) return puts(&quot;NO&quot;), 0; // {4}
	return puts(&quot;YES&quot;), 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF1365E@洛谷 | 1365E@Codeforces 【Maximum Subsequence Value】]]></title>
        <id>https://blog.ak-ioi.cf/post/solution-luogu-cf1365e-codeforces-1365e/</id>
        <link href="https://blog.ak-ioi.cf/post/solution-luogu-cf1365e-codeforces-1365e/">
        </link>
        <updated>2021-01-17T15:01:35.000Z</updated>
        <content type="html"><![CDATA[<p>思路：</p>
<p>考虑如何使取出的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个数价值最大。</p>
<p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>∈</mo><mrow><mo fence="true">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">k\in\left\{1,2,3\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span>，根据定义，若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 个数中至少有一个数的二进制位 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span> 上是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，则价值增加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span>，这个定义十分眼熟，发现就是按位或的结果。对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>≥</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">k\ge 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83041em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 每增加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，就会使 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>max</mi><mo>⁡</mo><mrow><mo fence="true">(</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mo>−</mo><mn>2</mn><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\max\left(1,k-2\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span> 增加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，因此每个二进制位的出现次数都需要加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 才能使答案更优，显然不如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">k=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 的情况。</p>
<p>因此对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∈</mo><mrow><mo fence="true">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">n\in\left\{1,2\right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span>，答案即为这些数的或；对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≥</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">n\ge 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>，答案为数列任取三个数能得到的最大的或。可以花费 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathcal" style="margin-right:0.02778em;">O</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 枚举取的三个数得到答案。</p>
<p>因为懒得特判前者，我选择牺牲了一定的代码常数，将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">i,j,k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 都从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 枚举到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，但是对于前者也能得到正确的结果。</p>
<hr>
<p>代码：</p>
<pre><code class="language-cpp">//By: Luogu@rui_er(122461)
#include &lt;bits/stdc++.h&gt;
#define loop while(true)
#define rep(x,y,z) for(ll x=y;x&lt;=z;x++)
#define per(x,y,z) for(ll x=y;x&gt;=z;x--)
#define fil(x,y) memset(x, y, sizeof(x))
#define mulT0 ll T; for(scanf(&quot;%lld&quot;, &amp;T);T;T--)
#define mulT1 ll T, rnds; for(scanf(&quot;%lld&quot;, &amp;T),rnds=1;rnds&lt;=T;rnds++)
using namespace std;
typedef long long ll;
const ll N = 505;

ll n, a[N], ans;

int main() {
	scanf(&quot;%lld&quot;, &amp;n);
	rep(i, 1, n) scanf(&quot;%lld&quot;, &amp;a[i]);
	rep(i, 1, n) rep(j, 1, n) rep(k, 1, n) ans = max(ans, a[i]|a[j]|a[k]);
	printf(&quot;%lld\n&quot;, ans);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 P7262@洛谷 【Get Your Wish】]]></title>
        <id>https://blog.ak-ioi.cf/post/solution-luogu-p7262/</id>
        <link href="https://blog.ak-ioi.cf/post/solution-luogu-p7262/">
        </link>
        <updated>2021-01-10T13:45:23.000Z</updated>
        <content type="html"><![CDATA[<p>题意很清楚了这里就不过多解释了，说一下思路：</p>
<p>一看题，感觉很多水滴的时候较难模拟下落过程，因此考虑根据给出的重力方向和电子元件反推。我们使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 表示如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(i,j\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span> 位置有水滴，是否会影响到电子元件。则以方向竖直向下为例，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>s</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">∣</mi><mrow><mo fence="true">(</mo><mtext>当前位置有水滴</mtext><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">s_{i,j}=s_{i,j+1}|\left(\text{当前位置有水滴}\right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord text"><span class="mord cjk_fallback">当前位置有水滴</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span></span></span></span>，其他三个方向以此类推，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span></span></span></span> 表示或，即两个条件中任一满足则为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。</p>
<p>然后枚举整个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n\times m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的图：如果存在水滴使对应位置的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">s_{i,j}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，则答案必定为 <code>GG</code>；若对于所有水滴对应位置的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>s</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">s_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> 均为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>，则答案为 <code>OK</code>。</p>
<p>赛时代码：</p>
<pre><code class="language-cpp">//By: Luogu@rui_er(122461)
#include &lt;bits/stdc++.h&gt;
#define loop while(true)
#define rep(x,y,z) for(int x=y;x&lt;=z;x++)
#define per(x,y,z) for(int x=y;x&gt;=z;x--)
#define fil(x,y) memset(x, y, sizeof(x))
#define mulT0 int T; for(scanf(&quot;%d&quot;, &amp;T);T;T--)
#define mulT1 int T, rnds; for(scanf(&quot;%d&quot;, &amp;T),rnds=1;rnds&lt;=T;rnds++)
using namespace std;
typedef long long ll;
const int N = 105;
//const char nxt[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};

int n, m, pos, s[N][N], ans = 0;
char mp[N][N], poss[N];

int main() {
	scanf(&quot;%d%d%s&quot;, &amp;n, &amp;m, poss+1);
	rep(i, 1, n) scanf(&quot;%s&quot;, mp[i]+1);
	pos = (poss[1] == 'v' ? 1 : (poss[1] == '&lt;' ? 2 : (poss[1] == '^' ? 3 : 0)));
	if(!pos) rep(i, 1, n) per(j, m, 1) s[i][j] = s[i][j+1] | (mp[i][j] == 'x');
	else if(pos == 1) rep(j, 1, m) per(i, n, 1) s[i][j] = s[i+1][j] | (mp[i][j] == 'x');
	else if(pos == 2) rep(i, 1, n) rep(j, 1, m) s[i][j] = s[i][j-1] | (mp[i][j] == 'x');
	else rep(j, 1, m) rep(i, 1, n) s[i][j] = s[i-1][j] | (mp[i][j] == 'x');
	rep(i, 1, n) rep(j, 1, m) ans |= (s[i][j] &amp;&amp; (mp[i][j] == 'o'));
	printf(&quot;%s\n&quot;, (char*[]){&quot;OK&quot;, &quot;GG&quot;}[ans]);
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CSP2020-S & NOIP2020 & THUPC2021 游记]]></title>
        <id>https://blog.ak-ioi.cf/post/i-ak-csp2020-s-noip2020-thupc2021/</id>
        <link href="https://blog.ak-ioi.cf/post/i-ak-csp2020-s-noip2020-thupc2021/">
        </link>
        <updated>2020-12-15T09:55:21.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>https://www.luogu.com.cn/blog/ak-ioi/i-ak-csp2020</li>
<li>https://www.luogu.com.cn/blog/ak-ioi/i-ak-noip2020-qwq</li>
<li>https://www.luogu.com.cn/blog/ak-ioi/i-ak-thupc2021</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF197B@洛谷 | 197B@Codeforces 【Limit】]]></title>
        <id>https://blog.ak-ioi.cf/post/solution-luogu-cf197b-codeforces-197b/</id>
        <link href="https://blog.ak-ioi.cf/post/solution-luogu-cf197b-codeforces-197b/">
        </link>
        <updated>2020-12-15T09:53:37.000Z</updated>
        <content type="html"><![CDATA[<p>题意：给定两个多项式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo separator="true">,</mo><mi>Q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">P(x),Q(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">Q</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>，求 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mstyle scriptlevel="0" displaystyle="true"><munder><mi>lim</mi><mo>⁡</mo><mrow><mi>x</mi><mo>→</mo><mo>+</mo><mi mathvariant="normal">∞</mi></mrow></munder><mfrac><mrow><mi>P</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><mrow><mi>Q</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\displaystyle\lim_{x\to+\infty}\frac{P(x)}{Q(x)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-2.1em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mrel mtight">→</span><span class="mord mtight">+</span><span class="mord mtight">∞</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">lim</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.758331em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 的值。</p>
<hr>
<p>乍一看好像很难，但考虑当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 趋近于无穷大时，多项式除最高次项以外的影响可以忽略。</p>
<p>经过少许数学推导<s>和大量猜测</s>，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 的次数低于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> 时，这个极限为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>；当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 的次数高于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> 时，这个极限为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">-\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">∞</span></span></span></span>；当次数相同时，这个极限为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> 最高次项与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> 最高次项的比值，记得约分。</p>
<hr>
<p>代码：</p>
<p>养成了一个习惯，就是用 <code>veryImportantVariable</code> 来存一些完全没用但要读入的东西（（（</p>
<pre><code class="language-cpp">//By: Luogu@rui_er(122461)
#include &lt;bits/stdc++.h&gt;
#define loop while(true)
#define rep(x,y,z) for(ll x=y;x&lt;=z;x++)
#define per(x,y,z) for(ll x=y;x&gt;=z;x--)
#define fil(x,y) memset(x, y, sizeof(x))
using namespace std;
typedef long long ll;

int n, m, a, b, veryImportantVariable;

int main() {
	scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
	if(n &lt; m) return puts(&quot;0/1&quot;), 0;
	scanf(&quot;%d&quot;, &amp;a); rep(i, 1, n) scanf(&quot;%d&quot;, &amp;veryImportantVariable);
	scanf(&quot;%d&quot;, &amp;b); rep(i, 1, m) scanf(&quot;%d&quot;, &amp;veryImportantVariable);
	if(a * b &lt; 0) a = abs(a), b = abs(b), putchar('-');
	if(n &gt; m) return puts(&quot;Infinity&quot;), 0;
	int qwq = __gcd(a, b); a /= qwq; b /= qwq;
	printf(&quot;%d/%d\n&quot;, a, b);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 AT3577@洛谷 | 3577@AtCoder 【Largest Smallest Cyclic Shift】]]></title>
        <id>https://blog.ak-ioi.cf/post/solution-luogu-at3577-atcoder-3577/</id>
        <link href="https://blog.ak-ioi.cf/post/solution-luogu-at3577-atcoder-3577/">
        </link>
        <updated>2020-11-25T14:45:06.000Z</updated>
        <content type="html"><![CDATA[<p>这题在 AtCoder 的评分是 3266，感觉肯定是黑题，但是咋就通过了呢（</p>
<p>题意翻译的不够清楚，重新解释一遍：（做这题的时候看了好久也没看懂，然后就去原题看英文题面了）</p>
<p>定义 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span> 为：对于一个字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>，每次将它最左边的字符放置到字符串末尾生成的字符串集合中，字典序最小的字符串。例如：对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 为 <code>bcbca</code> 的情况，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span> 即为 <code>babca</code>、<code>abcab</code>、<code>bcaba</code>、<code>cabab</code>、<code>abcbc</code> 中最小的那个，即 <code>abcbc</code>。</p>
<p>你需要构造一个字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span>，共包含 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span></span></span></span> 个字符 <code>a</code>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span> 个字符 <code>b</code> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Z</mi></mrow><annotation encoding="application/x-tex">Z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span></span></span></span> 个字符 <code>c</code>，使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>T</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span> 尽可能大，输出这个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>T</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span>。</p>
<hr>
<p>思路：</p>
<p>要使得 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>T</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span> 尽可能大，每次循环求一遍显然不现实，最好构造出一种 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> 使得它本身就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>T</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span>（即：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>f</mi><mo>(</mo><mi>T</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T=f(T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span>）。</p>
<p>那么怎么构造呢？</p>
<p>我们可以使用 <code>multiset</code> 来记录所有供选择的字符串，每次合并两个字符串，直到集合中只剩一个为止。合并的方法是取最小的字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 与最大的字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 拼接到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 后面，重新加入集合。</p>
<p>这种情况下，这个前缀因为是最小的，所以从任何其它地方开头取字符串均不会更小，保证了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo>=</mo><mi>f</mi><mo>(</mo><mi>T</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">T=f(T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span>。</p>
<hr>
<p>代码：</p>
<pre><code class="language-cpp">//By: Luogu@rui_er(122461)
#include &lt;bits/stdc++.h&gt;
#define loop while(true)
#define rep(x,y,z) for(int (x)=(y);(x)&lt;=(z);(x)++)
#define per(x,y,z) for(int (x)=(y);(x)&gt;=(z);(x)--)
#define fil(x,y) memset((x), (y), sizeof(x))
using namespace std;
typedef long long ll;

int x, y, z; multiset&lt;string&gt; qwq;

int main() {
	scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);
	rep(i, 1, x) qwq.insert(&quot;a&quot;);
	rep(i, 1, y) qwq.insert(&quot;b&quot;);
	rep(i, 1, z) qwq.insert(&quot;c&quot;);
	while(qwq.size() ^ 1) {
		multiset&lt;string&gt;::iterator         it1 = qwq.begin();
		multiset&lt;string&gt;::reverse_iterator it2 = qwq.rbegin();
		string a = (*it1), b = (*it2), _ = a + b;
		qwq.erase(qwq.lower_bound(a)); qwq.erase(qwq.lower_bound(b));
		qwq.insert(_);
	}
	multiset&lt;string&gt;::iterator it = qwq.begin();
	cout&lt;&lt;(*it)&lt;&lt;endl;
	return 0;
}
</code></pre>
<p>（顺带一提，无意中还抢到了 <a href="https://www.luogu.com.cn/record/42600000">R42600000</a>，虽然有个地方错了 QAQAQ）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[题解 CF843B@洛谷 | 843B@Codeforces 【Interactive LowerBound】]]></title>
        <id>https://blog.ak-ioi.cf/post/solution-luogu-cf843b-codeforces-843b/</id>
        <link href="https://blog.ak-ioi.cf/post/solution-luogu-cf843b-codeforces-843b/">
        </link>
        <updated>2020-11-06T10:18:37.000Z</updated>
        <content type="html"><![CDATA[<p>有趣的交互题。</p>
<p>题意：有一个递增的单向链表，需要通过询问权值和下一项编号，求出其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\ge x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的最小元素。</p>
<p>这还不简单？挨个询问一遍就切了嘛（</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≤</mo><mn>50000</mn></mrow><annotation encoding="application/x-tex">n\le 50000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，询问最多 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2000</mn></mrow><annotation encoding="application/x-tex">2000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 次。</p>
<p><s>笑容逐渐凝固。</s></p>
<hr>
<p>考虑其他方法：</p>
<p>因为已知该链表是递增的，可以先随机询问 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>min</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mo separator="true">,</mo><mn>1000</mn><mo>)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\min(n,1000)-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个点，记录好 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\le x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的最大元素以及他下一项的地址。因为询问数远小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的最大可能值，我们将这些询问近似地看做随机的。</p>
<p>经过这些询问后，如果最大元素恰好为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，直接输出即可，因为不能得到更小的解了。</p>
<p>否则，我们从下一项的地址开始询问最多 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span> 次（因为地址随机，两个被询问的数之间数的个数的期望可以通过除法求得，远小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1000</mn></mrow><annotation encoding="application/x-tex">1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>），每次移动到获取的 nxt 指针，直到该指针为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 或找到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≥</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\ge x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的数。对于第二种，因为单调递增的性质，可以知道获取到的是最优解，直接输出；对于第一种，跳出循环后判断最大值与 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的大小关系，输出该值或者 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 即可。</p>
<p>注意几点：</p>
<ol>
<li>经过几次错误，发现这里翻译得很毒瘤，实际上只能进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1999</mn></mrow><annotation encoding="application/x-tex">1999</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mord">9</span><span class="mord">9</span></span></span></span> 次询问（原文如此，经尝试也确实如此），注意不要被坑。</li>
<li>C++ 的 <code>rand()</code> 好像被毒瘤出题人卡掉了，换了几种方式都在第六个点错了，这里可以利用 int 自然溢出手写一个随机。</li>
</ol>
<p>甚至这个都被卡了：</p>
<pre><code class="language-cpp">srand(time(0));
srand(rand()); srand(rand()+19849);
</code></pre>
<p>我是用的随机函数可以见代码。</p>
<hr>
<p>代码：</p>
<pre><code class="language-cpp">//By: Luogu@rui_er(122461)
#include &lt;bits/stdc++.h&gt;
#define loop while(true)
#define rep(x,y,z) for(int (x)=(y);(x)&lt;=(z);(x)++)
#define per(x,y,z) for(int (x)=(y);(x)&gt;=(z);(x)--)
#define fil(x,y) memset((x), (y), sizeof(x))
using namespace std;
typedef long long ll;
const int N = 5e4+5, inf = 0x3f3f3f3f;

int n, front, x, ans = -inf, nxt;
vector&lt;int&gt; interact(int _) {
	printf(&quot;? %d\n&quot;, _);
	fflush(stdout);
	int a, b;
	scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
	return vector&lt;int&gt;({a, b});
}
void give(int _) {
	printf(&quot;! %d\n&quot;, _);
	fflush(stdout);
}

int seed, seed2;
void srand(int x, int y) {seed = x; seed2 = y;}
int frand() {return (seed *= 19260817) += ((seed2 += 114514) ^= 1919810);}
int rand() {int res = frand(); while(res &lt;= 0) res += n; return res;}

int main() {
//	srand(time(0));
//	srand(rand()); srand(rand()+19849);
	srand(998244353, 1000000007);
//	rep(i, 1, 100) printf(&quot;%d %d %d\n&quot;, seed, seed2, rand());
	scanf(&quot;%d%d%d&quot;, &amp;n, &amp;front, &amp;x);
	nxt = front;
	rep(i, 1, min(n, 1000)-1) {
		int pos = rand() % n + 1;
		vector&lt;int&gt; res = interact(pos);
		if(res[0] &lt;= x &amp;&amp; res[0] &gt; ans) nxt = res[1], ans = res[0];
	}
	if(ans == x) return give(x), 0;
	rep(i, 1, 1000) {
		if(nxt == -1) break;
		vector&lt;int&gt; res = interact(nxt);
		if(res[0] &gt;= x) return give(res[0]), 0;
		ans = res[0]; nxt = res[1];
	}
	give(ans&gt;=x?ans:-1);
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>